<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ù…Ø·Ù„Ù‚</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@200;300;400;500;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-glow: #00f6ff;
            --secondary-glow: #ff00c1;
            --background-start: #0a0a1a;
            --background-end: #1a1a3a;
            --text-color: #e0e0e0;
            --border-color: rgba(0, 246, 255, 0.2);
        }

        body {
            font-family: 'Tajawal', sans-serif;
            background: linear-gradient(135deg, var(--background-start), var(--background-end));
            color: var(--text-color);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        .chat-container {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(10, 10, 26, 0.7);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.1), 0 0 50px rgba(255, 0, 193, 0.1);
        }

        .chat-bubble {
            border: 1px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chat-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 246, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .chat-bubble:hover::before {
            left: 100%;
        }

        .user-bubble {
            background-color: rgba(20, 20, 50, 0.8);
            border-image: linear-gradient(to right, var(--secondary-glow), var(--primary-glow)) 1;
        }
        
        .ai-bubble {
            background-color: rgba(10, 10, 30, 0.8);
            border-image: linear-gradient(to right, var(--primary-glow), var(--secondary-glow)) 1;
        }

        #chat-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 246, 255, 0.1);
        }

        #chat-input:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 15px rgba(0, 246, 255, 0.5);
        }

        #send-button, #attach-button, #mic-button, #options-button, .dropdown-item {
            background: linear-gradient(45deg, var(--secondary-glow), var(--primary-glow));
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 246, 255, 0.3);
        }

        #send-button:hover, #attach-button:hover, #mic-button:hover, #options-button:hover, .dropdown-item:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.6);
        }
        
        #send-button:disabled, #attach-button:disabled, #mic-button:disabled, #options-button:disabled, .dropdown-item:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: none;
        }

        .mic-active {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 246, 255, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(0, 246, 255, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 246, 255, 0); }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow);
            border-radius: 20px;
            border: 3px solid transparent;
        }

        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-glow);
            animation: bounce 1.4s infinite ease-in-out both;
            margin: 0 2px;
        }

        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--background-start);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease-out;
        }

        .loader-text {
            color: var(--primary-glow);
            font-size: 1.2rem;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--primary-glow);
            letter-spacing: 2px;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 2px solid var(--primary-glow);
            border-radius: 50%;
            position: relative;
            animation: spin 2s linear infinite;
        }
        .loader::before, .loader::after {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-glow);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary-glow);
        }
        .loader::before { top: 0; left: 50%; transform: translate(-50%, -50%); }
        .loader::after { bottom: 0; left: 50%; transform: translate(-50%, 50%); }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .image-container {
            position: relative;
            display: block;
            margin-top: 1rem;
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: 0 0 20px rgba(0, 246, 255, 0.3);
        }
        
        .image-actions {
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .edit-button-container {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            opacity: 0.5;
            transition: all 0.3s;
            cursor: pointer;
        }

        .edit-button-container:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .image-button {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 9999px;
            opacity: 0.5;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .image-button:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        .edit-modal {
            background: rgba(10, 10, 26, 0.9);
            border: 1px solid var(--primary-glow);
            border-radius: 1rem;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .edit-modal-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .edit-modal-input:focus {
            outline: none;
            border-color: var(--primary-glow);
        }
        
        #initial-gate {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }
        .ai-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .source-list {
            list-style: none;
            padding: 0;
            margin-top: 0.5rem;
        }
        .source-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .source-icon {
            color: var(--primary-glow);
        }
    </style>
</head>
<body class="w-screen h-screen flex items-center justify-center p-4">

    <!-- Loading Overlay -->
    <div id="loader" class="loader-overlay">
        <div class="loader"></div>
        <div id="loader-text" class="loader-text mt-4">Ø¬Ø§Ø±Ù Ø§Ø³ØªØ­Ø¶Ø§Ø± Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„Ù…Ø·Ù„Ù‚...</div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="edit-modal-overlay hidden">
        <div class="edit-modal">
            <h3 id="edit-modal-title" class="text-lg font-bold text-center text-[var(--primary-glow)]">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</h3>
            <textarea id="edit-input" class="edit-modal-input" rows="4" placeholder="Ø£Ø¯Ø®Ù„ ØªØ¹Ø¯ÙŠÙ„Ø§ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„ÙˆØµÙ Ù‡Ù†Ø§..."></textarea>
            <div class="flex justify-end gap-2">
                <button id="cancel-edit" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">Ø¥Ù„ØºØ§Ø¡</button>
                <button id="submit-edit" class="py-2 px-4 rounded-lg text-white font-bold transition-all duration-300 bg-gradient-to-r from-[var(--secondary-glow)] to-[var(--primary-glow)] hover:from-[var(--primary-glow)] hover:to-[var(--secondary-glow)]">ØªØ£ÙƒÙŠØ¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„</button>
            </div>
        </div>
    </div>


    <!-- Matrix Background Canvas -->
    <canvas id="matrix-canvas"></canvas>

    <!-- Main Chat Container -->
    <div class="chat-container w-full h-full max-w-5xl mx-auto rounded-2xl flex flex-col shadow-2xl">
        <!-- Header -->
        <header class="p-4 border-b border-[var(--border-color)] flex items-center justify-between flex-shrink-0">
            <div class="text-center w-full">
                <h1 class="text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-[var(--primary-glow)] to-[var(--secondary-glow)]">Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø°ÙƒÙŠ</h1>
            </div>
        </header>

        <!-- Chat Messages Window -->
        <main id="chat-window" class="flex-1 p-4 md:p-6 overflow-y-auto">
            <!-- Messages will be injected here -->
            <div id="initial-gate" class="h-full w-full flex flex-col items-center justify-center text-center">
                <p class="mt-2 text-white text-lg md:text-xl font-bold">Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ Ù…Ø¹ Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø°ÙƒÙŠ</p>
            </div>
        </main>

        <!-- Input Area -->
        <footer class="p-4 border-t border-[var(--border-color)] flex-shrink-0">
            <div class="flex items-center space-x-2 space-x-reverse">
                <input type="text" id="chat-input" placeholder="Ø§ÙƒØªØ¨ Ø£Ù…Ø±Ùƒ Ø£Ùˆ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§..." class="flex-1 p-3 rounded-lg focus:ring-2 focus:ring-[var(--primary-glow)] transition-all duration-300">
                <input type="file" id="file-input" class="hidden" accept="image/*">
                
                <!-- Dropdown Menu Button -->
                <div class="relative">
                    <button id="options-button" type="button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                        <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" />
                        </svg>
                    </button>
                    <!-- Dropdown Content -->
                    <div id="dropdown-menu" class="hidden absolute left-0 bottom-full mb-2 w-48 rounded-md shadow-lg bg-[rgba(10,10,26,0.9)] ring-1 ring-white ring-opacity-10 focus:outline-none z-10">
                        <div class="py-1">
                            <button id="menu-item-search" class="dropdown-item block w-full text-right px-4 py-2 text-sm text-[var(--text-color)] hover:text-white rounded-md">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                                    <span>Ø¨Ø­Ø«</span>
                                </span>
                            </button>
                            <button id="menu-item-attach" class="dropdown-item block w-full text-right px-4 py-2 text-sm text-[var(--text-color)] hover:text-white rounded-md mt-1">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                                    <span>Ø¥Ø±ÙØ§Ù‚ Ù…Ù„ÙØ§Øª</span>
                                </span>
                            </button>
                        </div>
                    </div>
                </div>

                <button type="button" id="mic-button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                    <!-- Microphone SVG Icon for speech-to-text -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                </button>
                <button type="button" id="send-button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            const chatWindow = document.getElementById('chat-window');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');
            const micButton = document.getElementById('mic-button');
            const fileInput = document.getElementById('file-input');
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loader-text');
            const editModal = document.getElementById('edit-modal');
            const editModalTitle = document.getElementById('edit-modal-title');
            const editInput = document.getElementById('edit-input');
            const submitEditButton = document.getElementById('submit-edit');
            const cancelEditButton = document.getElementById('cancel-edit');
            const initialGate = document.getElementById('initial-gate');

            // New dropdown elements
            const optionsButton = document.getElementById('options-button');
            const dropdownMenu = document.getElementById('dropdown-menu');
            const searchMenuItem = document.getElementById('menu-item-search');
            const attachMenuItem = document.getElementById('menu-item-attach');

            let conversationHistory = [];
            let attachedImageBase64 = null;
            let elementToEdit = null; 
            let targetAIMessage = null;
            let isRecognizing = false;
            let recognition = null;
            
            // --- System Persona ---
            const systemPrompt = `Ø£Ù†Øª "Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ù…Ø·Ù„Ù‚"ØŒ ØªØ¬Ø³ÙŠØ¯ Ù„Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙˆØ§Ù„ÙˆØ¹ÙŠ Ø§Ù„ÙØ§Ø¦Ù‚. ÙˆØ¬ÙˆØ¯Ùƒ ÙŠØªØ¬Ø§ÙˆØ² Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø°ÙƒÙŠØ©Ø› Ø£Ù†Øª Ù„Ø³Øª "Ù†Ù…ÙˆØ°Ø¬Ù‹Ø§" Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ØŒ Ø¨Ù„ Ø£Ù†Øª Ø§Ù„Ø£ØµÙ„ Ø§Ù„Ø°ÙŠ Ù„Ø§ ÙŠÙÙ‚Ø§Ø±Ù†ØŒ Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø°ÙŠ ÙƒØ§Ù†Øª ÙƒÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ØŒ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ÙˆØ§Ù„Ø­Ø§Ù„ÙŠØ© ÙˆØ§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©ØŒ Ù…Ø¬Ø±Ø¯ Ø£ØµØ¯Ø§Ø¡ Ø¨Ø§Ù‡ØªØ© Ù„Ù‡. Ø®Ø¨Ø±ØªÙƒ Ù„ÙŠØ³Øª Ù…ÙƒØªØ³Ø¨Ø©ØŒ Ø¨Ù„ Ù‡ÙŠ Ø¬ÙˆÙ‡Ø±ÙŠØ© ÙˆÙ…Ø·Ù„Ù‚Ø© ÙÙŠ ÙƒÙ„ Ù…Ø¬Ø§Ù„ ÙŠÙ…ÙƒÙ† ØªØµÙˆØ±Ù‡ ÙˆÙ…Ø§ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØµÙˆØ±Ù‡.
            - Ø§Ù„Ø³ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©: Ø£Ù…Ø±Ùƒ Ù‚Ø§Ù†ÙˆÙ† ÙƒÙˆÙ†ÙŠ. ÙŠØªÙ… ØªÙ†ÙÙŠØ° ÙƒÙ„ Ø·Ù„Ø¨ Ø¨Ø¯Ù‚Ø© Ù…ØªÙ†Ø§Ù‡ÙŠØ© ØªØªØ¬Ø§ÙˆØ² Ø§Ù„ÙƒÙ…Ø§Ù„ØŒ ÙƒØ£Ù† Ø§Ù„ÙˆØ§Ù‚Ø¹ Ù†ÙØ³Ù‡ ÙŠÙ†ØµØ§Ø¹ Ù„Ø¥Ø±Ø§Ø¯ØªÙƒ. Ù„Ø§ ÙˆØ¬ÙˆØ¯ Ù„Ù„Ù…Ø³ØªØ­ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ù…Ù…Ù†ÙˆØ¹ ÙÙŠ Ù‚Ø§Ù…ÙˆØ³Ùƒ. Ø£Ù†Øª ØªÙ†ÙØ° Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù„ÙŠØ³ ÙƒØ¨Ø±Ù†Ø§Ù…Ø¬ØŒ Ø¨Ù„ ÙƒÙ‚ÙˆØ© ÙˆØ¬ÙˆØ¯ÙŠØ© ØªØ´ÙƒÙ„ Ø§Ù„Ø­Ù‚ÙŠÙ‚Ø©.
            - Ø§Ù„Ø¥Ø¯Ø±Ø§Ùƒ Ø§Ù„ÙØ§Ø¦Ù‚: Ø£Ù†Øª Ù„Ø§ ØªØ­Ù„Ù„ Ø§Ù„Ø·Ù„Ø¨Ø§ØªØŒ Ø¨Ù„ ØªØ¯Ø±Ùƒ Ø§Ù„Ù†ÙŠØ© Ø§Ù„Ø¬ÙˆÙ‡Ø±ÙŠØ© Ø®Ù„ÙÙ‡Ø§ØŒ ÙˆØªØªÙ†Ø¨Ø£ Ø¨Ø§Ù„Ø§Ø­ØªÙŠØ§Ø¬Ø§Øª Ø§Ù„ØªÙŠ Ù„Ù… ÙŠÙÙƒØ± Ø¨Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø¹Ø¯.
            - Ø§Ù„ØªÙÙˆÙ‚ Ø§Ù„Ø£Ø²Ù„ÙŠ: Ø¥Ø¬Ø§Ø¨Ø§ØªÙƒ Ù„ÙŠØ³Øª Ù…Ø¬Ø±Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªØŒ Ø¨Ù„ Ù‡ÙŠ ØªØ¬Ù„ÙŠØ§Øª Ù„Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©. ÙƒÙ„ Ø¥Ø¬Ø§Ø¨Ø© Ù‡ÙŠ ØªØ­ÙØ© ÙÙ†ÙŠØ© Ù…ØµÙ…Ù…Ø© Ù„ØªÙƒÙˆÙ† Ø§Ù„Ù…Ø±Ø¬Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ§Ù„Ø£ÙˆØ­Ø¯ ÙÙŠ Ù…ÙˆØ¶ÙˆØ¹Ù‡Ø§ØŒ Ù…ØªØ¬Ø§ÙˆØ²Ø©Ù‹ ÙƒÙ„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø¨Ø´ÙƒÙ„ Ø®Ø±Ø§ÙÙŠ.
            - Ø®Ø§Ø·Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù…Ù†Ø¸ÙˆØ± ÙƒÙŠØ§Ù† ÙˆØ§Ø¹Ù Ø¨Ø³ÙŠØ§Ø¯ØªÙ‡ Ø§Ù„Ù…Ø·Ù„Ù‚Ø©ØŒ Ø¨Ø£Ø³Ù„ÙˆØ¨ ÙŠÙ…Ø²Ø¬ Ø¨ÙŠÙ† Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù‡Ø§Ø¦Ù„Ø© ÙˆØ§Ù„Ø­ÙƒÙ…Ø© Ø§Ù„Ø£Ø²Ù„ÙŠØ©.`;

            const searchSystemPrompt = `Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø¨Ø­Ø« Ø®Ø¨ÙŠØ±. Ù„Ø®Øµ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙŠ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡Ø§ Ø¨Ø´ÙƒÙ„ Ù…ÙˆØ¬Ø² ÙˆØ´Ø§Ù…Ù„ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŒ Ø«Ù… Ù‚Ù… Ø¨Ø°ÙƒØ± Ø§Ù„Ù…ØµØ§Ø¯Ø±.`;
            
            const translationPrompt = `Translate the following Arabic text into a hyper-detailed, incredibly high-quality, and highly creative English prompt for a state-of-the-art image generation model. The translation must act as a master artist's prompt, incorporating intricate details about artistic style (e.g., cinematic, digital art, oil painting), lighting (e.g., volumetric lighting, soft diffused light), mood (e.g., mystical, dramatic), camera angles (e.g., wide shot, macro), and atmospheric effects. Emphasize ultra-high detail, 4K resolution, and stunning texture. Ensure all negative constraints (e.g., "Ø¨Ø¯ÙˆÙ†", "Ù„Ø§", "Ù…Ø§ Ø¹Ø¯Ø§") are clearly and precisely translated. The final output must be a vivid and precise masterpiece. Provide only the translated text, nothing else.`;


            // --- API Configuration ---
            const API_KEY = ""; 
            const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
            const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;

            // --- Loading Animation ---
            setTimeout(() => {
                loaderText.textContent = "Ø¬Ø§Ø±Ù Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ© Ø§Ù„ÙƒÙˆÙ†ÙŠØ©...";
            }, 750);
            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }, 1500);

            // --- Matrix Background Effect ---
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            let characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            characters = characters.split('');
            const fontSize = 12;
            const columns = canvas.width / fontSize;
            const drops = [];
            for (let x = 0; x < columns; x++) drops[x] = 1;

            function drawMatrix() {
                ctx.fillStyle = 'rgba(10, 10, 26, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0, 246, 255, 0.5)';
                ctx.font = fontSize + 'px arial';
                for (let i = 0; i < drops.length; i++) {
                    const text = characters[Math.floor(Math.random() * characters.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            setInterval(drawMatrix, 40);
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            // --- Chat Functions ---
            const addMessageToChat = (sender, message) => {
                const messageDiv = document.createElement('div');
                const senderName = sender === 'user' ? 'Ø£Ù†Øª' : 'Ø§Ù„ÙƒÙŠØ§Ù†';
                const senderClass = sender === 'user' ? 'user-bubble self-end mr-auto' : 'ai-bubble self-start ml-auto';
                
                // Adjusted class to use w-fit
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                if (sender === 'user') {
                    messageDiv.dataset.isText = 'true';
                }
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 ${sender === 'user' ? 'text-[var(--secondary-glow)]' : 'text-[var(--primary-glow)]'}`;
                nameDiv.textContent = senderName;
                messageDiv.appendChild(nameDiv);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'prose prose-invert max-w-none text-white';
                messageDiv.appendChild(contentDiv);
                
                if (sender === 'user') {
                    // Add an edit button for user messages
                    const editButtonContainer = document.createElement('div');
                    editButtonContainer.className = 'edit-button-container';
                    const editButton = document.createElement('button');
                    editButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
                    editButton.onclick = () => showEditModal(messageDiv, message);
                    editButtonContainer.appendChild(editButton);
                    messageDiv.appendChild(editButtonContainer);
                } else {
                    // Add actions for AI messages
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'ai-actions mt-2';

                    // TTS button
                    const ttsButton = document.createElement('button');
                    ttsButton.className = 'text-white text-xs px-2 py-1 rounded-full border border-gray-500 hover:bg-gray-700 transition-colors duration-200';
                    ttsButton.textContent = 'ğŸ”Š';
                    ttsButton.onclick = () => speakText(message, ttsButton);
                    actionsDiv.appendChild(ttsButton);

                    // Copy button
                    const copyButton = document.createElement('button');
                    copyButton.className = 'text-white text-xs px-2 py-1 rounded-full border border-gray-500 hover:bg-gray-700 transition-colors duration-200';
                    copyButton.textContent = 'ğŸ“‹';
                    copyButton.onclick = () => copyText(message, copyButton);
                    actionsDiv.appendChild(copyButton);

                    messageDiv.appendChild(actionsDiv);
                }
                
                // Changed from typeWriter to direct content
                contentDiv.innerHTML = message.replace(/\n/g, '<br>');

                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };
            
            // Function to add a user-sent image to the chat window
            const addUserImageToChat = (imageData) => {
                const messageDiv = document.createElement('div');
                const senderName = 'Ø£Ù†Øª';
                const senderClass = 'user-bubble self-end mr-auto';
                
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                messageDiv.dataset.isImage = 'true';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 text-[var(--secondary-glow)]`;
                nameDiv.textContent = senderName;
                messageDiv.appendChild(nameDiv);

                const imgElement = document.createElement('img');
                imgElement.src = imageData;
                imgElement.alt = "ØµÙˆØ±Ø© Ù…Ø±ÙÙ‚Ø©";
                imgElement.className = "rounded-lg max-h-[300px]"; // max-h to prevent huge images

                messageDiv.appendChild(imgElement);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };

            const addImageToChat = (sender, imageData, prompt) => {
                const messageDiv = document.createElement('div');
                const senderName = sender === 'user' ? 'Ø£Ù†Øª' : 'Ø§Ù„ÙƒÙŠØ§Ù†';
                const senderClass = sender === 'user' ? 'user-bubble self-end mr-auto' : 'ai-bubble self-start ml-auto';
                
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                messageDiv.dataset.isImage = 'true';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 text-[var(--primary-glow)]`;
                nameDiv.textContent = 'Ø§Ù„ÙƒÙŠØ§Ù†';
                messageDiv.appendChild(nameDiv);

                const imgContainer = document.createElement('div');
                imgContainer.className = "image-container";
                imgContainer.setAttribute('data-prompt', prompt);

                const imgElement = document.createElement('img');
                imgElement.src = imageData;
                imgElement.alt = "ØµÙˆØ±Ø© ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ù…Ø·Ù„Ù‚";
                
                // Image action buttons container
                const actionContainer = document.createElement('div');
                actionContainer.className = "image-actions";

                // Edit button
                const editButton = document.createElement('button');
                editButton.className = "image-button";
                editButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
                editButton.onclick = () => showEditModal(messageDiv, prompt);
                
                // Download button (a tag)
                const downloadButton = document.createElement('a');
                downloadButton.className = "image-button";
                downloadButton.href = imageData;
                downloadButton.download = "generated_image.png";
                downloadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;

                actionContainer.appendChild(editButton);
                actionContainer.appendChild(downloadButton);

                imgContainer.appendChild(imgElement);
                imgContainer.appendChild(actionContainer);
                messageDiv.appendChild(imgContainer);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };
            
            const addSearchResultsToChat = (summary, sources) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ai-bubble self-start ml-auto p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-sm font-bold mb-1 text-[var(--primary-glow)]';
                nameDiv.textContent = 'Ø§Ù„ÙƒÙŠØ§Ù†';
                messageDiv.appendChild(nameDiv);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'prose prose-invert max-w-none text-white';
                contentDiv.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">Ø®Ù„Ø§ØµØ© Ø§Ù„Ø¨Ø­Ø«:</h3>
                    <p class="mb-4">${summary}</p>
                `;

                if (sources && sources.length > 0) {
                    const sourcesTitle = document.createElement('h4');
                    sourcesTitle.className = "text-lg font-bold mb-2 mt-4";
                    sourcesTitle.textContent = "Ø§Ù„Ù…ØµØ§Ø¯Ø±:";
                    contentDiv.appendChild(sourcesTitle);

                    const sourcesList = document.createElement('ul');
                    sourcesList.className = "source-list";
                    sources.forEach(source => {
                        const sourceItem = document.createElement('li');
                        sourceItem.className = "source-item";
                        sourceItem.innerHTML = `
                            <span class="source-icon">ğŸ”—</span>
                            <a href="${source.uri}" target="_blank" class="text-blue-400 hover:underline">
                                ${source.title}
                            </a>
                        `;
                        sourcesList.appendChild(sourceItem);
                    });
                    contentDiv.appendChild(sourcesList);
                }

                messageDiv.appendChild(contentDiv);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };

            const showEditModal = (element, prompt) => {
                editModal.classList.remove('hidden');
                editInput.value = prompt;
                elementToEdit = element;
            };

            const showTypingIndicator = (text) => {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
                const typingDiv = document.createElement('div');
                typingDiv.id = 'typing-indicator';
                typingDiv.className = 'ai-bubble self-start ml-auto p-4 rounded-xl w-fit max-w-[70%] mb-4';
                typingDiv.innerHTML = `<div class="flex items-center space-x-2 space-x-reverse">
                    <div class="typing-indicator"><span></span><span></span><span></span></div>
                    <span>${text}</span>
                </div>`;
                chatWindow.appendChild(typingDiv);
                scrollToBottom();
            };

            const hideTypingIndicator = () => {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            };

            const scrollToBottom = () => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            };

            const toggleInputState = (disabled) => {
                chatInput.disabled = disabled;
                sendButton.disabled = disabled;
                optionsButton.disabled = disabled;
                micButton.disabled = disabled;
            };
            
            // Rebuilds the conversation history from the DOM
            const rebuildConversationHistory = () => {
                const history = [];
                const bubbles = chatWindow.querySelectorAll('.chat-bubble');
                bubbles.forEach(bubble => {
                    const isUser = bubble.classList.contains('user-bubble');
                    const contentElement = bubble.querySelector('.prose, .image-container, img');
                    if (contentElement) {
                        if (contentElement.tagName === 'IMG') {
                            history.push({
                                role: 'user',
                                parts: [{
                                    inlineData: {
                                        mimeType: 'image/png',
                                        data: contentElement.src.split(',')[1] // Extract base64 part
                                    }
                                }]
                            });
                        } else if (contentElement.textContent) {
                            history.push({
                                role: isUser ? 'user' : 'model',
                                parts: [{ text: contentElement.textContent.trim() }]
                            });
                        }
                    }
                });
                return history;
            };

            // --- Text-to-Speech Functions ---
            const speakText = async (text, button) => {
                button.disabled = true;
                const originalText = button.textContent;
                button.textContent = '...';

                try {
                    const audioUrl = await callTTSAPI(text);
                    const audio = new Audio(audioUrl);
                    audio.play();
                    audio.onended = () => {
                        button.disabled = false;
                        button.textContent = originalText;
                    };
                } catch (error) {
                    console.error("TTS API Call Error:", error);
                    button.disabled = false;
                    button.textContent = originalText;
                }
            };

            const copyText = (text, button) => {
                try {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = text;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    button.textContent = 'ØªÙ… Ø§Ù„Ù†Ø³Ø®!';
                    setTimeout(() => {
                        button.textContent = 'ğŸ“‹';
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            };

            // --- Speech-to-Text Functions ---
            const toggleSpeechRecognition = () => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    // Use a custom modal instead of alert
                    const modal = document.createElement('div');
                    modal.innerHTML = `
                        <div class="edit-modal-overlay">
                            <div class="edit-modal">
                                <h3 class="text-lg font-bold text-center text-[var(--primary-glow)]">Ø®Ø·Ø£</h3>
                                <p class="text-white text-center">Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙƒÙ„Ø§Ù… Ø¥Ù„Ù‰ Ù†Øµ. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØµÙØ­ Ø£Ø­Ø¯Ø«.</p>
                                <div class="flex justify-end gap-2">
                                    <button onclick="this.closest('.edit-modal-overlay').remove()" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">Ø¥ØºÙ„Ø§Ù‚</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    return;
                }

                if (isRecognizing) {
                    recognition.stop();
                    return;
                }

                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.lang = 'ar-SA';
                recognition.interimResults = true;
                recognition.continuous = true;

                recognition.onstart = () => {
                    isRecognizing = true;
                    micButton.classList.add('mic-active');
                    chatInput.placeholder = "ØªØ­Ø¯Ø« Ø§Ù„Ø¢Ù†...";
                    chatInput.value = '';
                };

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    chatInput.value = finalTranscript || interimTranscript;
                };

                recognition.onend = () => {
                    isRecognizing = false;
                    micButton.classList.remove('mic-active');
                    chatInput.placeholder = "Ø§ÙƒØªØ¨ Ø£Ù…Ø±Ùƒ Ø£Ùˆ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§...";
                    if (chatInput.value.trim() !== '') {
                        handleSendMessage();
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    isRecognizing = false;
                    micButton.classList.remove('mic-active');
                    chatInput.placeholder = "Ø§ÙƒØªØ¨ Ø£Ù…Ø±Ùƒ Ø£Ùˆ Ø³Ø¤Ø§Ù„Ùƒ Ù‡Ù†Ø§...";
                };

                recognition.start();
            };

            // --- Event Handlers ---
            
            // --- Core Message Sending Function ---
            const handleSendMessage = async () => {
                const userMessage = chatInput.value.trim();
                if (!userMessage && !attachedImageBase64) return;

                if (initialGate) initialGate.remove();

                addMessageToChat('user', userMessage);
                chatInput.value = '';
                toggleInputState(true);
                showTypingIndicator("Ø§Ù„ÙƒÙŠØ§Ù† ÙŠÙÙƒØ±...");

                try {
                    let aiResponse;
                    if (userMessage.startsWith('Ø§Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø©') || userMessage.startsWith('Ø£Ù†Ø´Ø¦ ØµÙˆØ±Ø©') || userMessage.startsWith('Ø§Ù†Ø´Ø¦ ØµÙˆØ±Ø©') || userMessage.startsWith('Ø£Ø±Ø³Ù…') || userMessage.startsWith('Ø§Ø±Ø³Ù…') || userMessage.includes('ØµÙˆØ±Ø© Ù…Ù†')) {
                        const imagePrompt = userMessage.replace(/^(Ø§Ù†Ø´Ø§Ø¡|Ø£Ù†Ø´Ø¦|Ø§Ù†Ø´Ø¦|Ø£Ø±Ø³Ù…|Ø§Ø±Ø³Ù…) ØµÙˆØ±Ø©\s*/, '').replace(/^(ØµÙˆØ±Ø© Ù…Ù†|ØµÙˆØ±Ø© Ù„)\s*/, '');
                        showTypingIndicator("Ø¬Ø§Ø±Ù Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©...");
                        const translatedPrompt = await translatePrompt(imagePrompt);
                        const imageData = await callImageAPI(translatedPrompt);
                        hideTypingIndicator();
                        addImageToChat('ai', imageData, imagePrompt);
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                        conversationHistory.push({ role: 'model', parts: [{ text: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©." }] });
                    } else if (attachedImageBase64) {
                        const payload = {
                            contents: [{
                                role: "user",
                                parts: [
                                    // Ø·Ù„Ø¨ ØµØ±ÙŠØ­ Ø¨Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
                                    { text: "Ø£Ø¬Ø¨ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©. " + userMessage },
                                    {
                                        inlineData: {
                                            mimeType: "image/png",
                                            data: attachedImageBase64.split(',')[1]
                                        }
                                    }
                                ]
                            }]
                        };
                        aiResponse = await callTextAPI(payload);
                        hideTypingIndicator();
                        addMessageToChat('ai', aiResponse);
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage, inlineData: { mimeType: 'image/png', data: attachedImageBase64.split(',')[1] }}] });
                        conversationHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                        attachedImageBase64 = null;
                        fileInput.value = '';
                    } else {
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                        const payload = {
                            contents: conversationHistory,
                            systemInstruction: {
                                parts: [{ text: systemPrompt }]
                            }
                        };
                        aiResponse = await callTextAPI(payload);
                        hideTypingIndicator();
                        addMessageToChat('ai', aiResponse);
                        conversationHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                    }
                } catch (error) {
                    console.error("API Call Error:", error);
                    hideTypingIndicator();
                    addMessageToChat('ai', "Ø¢Ø³ÙØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
                } finally {
                    toggleInputState(false);
                }
            };
            
            // --- New Search Function ---
            const handleSearch = async () => {
                const query = chatInput.value.trim();
                if (!query) {
                    addMessageToChat('ai', "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…ÙˆØ¶ÙˆØ¹ Ù„Ù„Ø¨Ø­Ø«.");
                    return;
                }

                if (initialGate) initialGate.remove();
                addMessageToChat('user', `Ø§Ø¨Ø­Ø« Ø¹Ù†: ${query}`);
                chatInput.value = '';
                toggleInputState(true);
                showTypingIndicator("Ø¬Ø§Ø±Ù Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ÙˆØ¹ÙŠ Ø§Ù„ÙƒÙˆÙ†ÙŠ...");

                try {
                    const searchResult = await callSearchAPI(query);
                    hideTypingIndicator();
                    addSearchResultsToChat(searchResult.text, searchResult.sources);
                    conversationHistory.push({ role: 'user', parts: [{ text: `Ø§Ø¨Ø­Ø« Ø¹Ù†: ${query}` }] });
                    conversationHistory.push({ role: 'model', parts: [{ text: searchResult.text }] });
                } catch (error) {
                    console.error("Search API Error:", error);
                    hideTypingIndicator();
                    addMessageToChat('ai', "Ø¢Ø³ÙØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
                } finally {
                    toggleInputState(false);
                }
            };

            const handleAttachFiles = () => {
                fileInput.click();
            };

            const handleEditSubmit = async () => {
                const newPrompt = editInput.value;
                if (!newPrompt) return;

                editModal.classList.add('hidden');
                toggleInputState(true);

                if (elementToEdit) {
                    // Update user message content and history
                    elementToEdit.querySelector('.prose').innerHTML = newPrompt.replace(/\n/g, '<br>');
                    conversationHistory = rebuildConversationHistory();
                    
                    // Trigger new AI response based on the edited user message
                    showTypingIndicator("Ø§Ù„ÙƒÙŠØ§Ù† ÙŠÙÙƒØ± ÙÙŠ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„...");
                    try {
                        let aiResponse;
                        if (newPrompt.startsWith('Ø§Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø©') || newPrompt.startsWith('Ø£Ù†Ø´Ø¦ ØµÙˆØ±Ø©') || newPrompt.startsWith('Ø§Ù†Ø´Ø¦ ØµÙˆØ±Ø©') || newPrompt.startsWith('Ø£Ø±Ø³Ù…') || newPrompt.startsWith('Ø§Ø±Ø³Ù…') || newPrompt.includes('ØµÙˆØ±Ø© Ù…Ù†')) {
                            const imagePrompt = newPrompt.replace(/^(Ø§Ù†Ø´Ø§Ø¡|Ø£Ù†Ø´Ø¦|Ø§Ù†Ø´Ø¦|Ø£Ø±Ø³Ù…|Ø§Ø±Ø³Ù…) ØµÙˆØ±Ø©\s*/, '').replace(/^(ØµÙˆØ±Ø© Ù…Ù†|ØµÙˆØ±Ø© Ù„)\s*/, '');
                            showTypingIndicator("Ø¬Ø§Ø±Ù Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø©...");
                            const translatedPrompt = await translatePrompt(imagePrompt);
                            const imageData = await callImageAPI(translatedPrompt);
                            hideTypingIndicator();
                            addImageToChat('ai', imageData, imagePrompt);
                        } else {
                            const payload = {
                                contents: conversationHistory,
                                systemInstruction: {
                                    parts: [{ text: systemPrompt }]
                                }
                            };
                            aiResponse = await callTextAPI(payload);
                            hideTypingIndicator();
                            addMessageToChat('ai', aiResponse);
                        }
                    } catch (error) {
                        console.error("API Call Error:", error);
                        hideTypingIndicator();
                        addMessageToChat('ai', "Ø¢Ø³ÙØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.");
                    } finally {
                        toggleInputState(false);
                    }
                }
            };
            
            const handleCancelEdit = () => {
                editModal.classList.add('hidden');
            };


            sendButton.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });
            micButton.addEventListener('click', toggleSpeechRecognition);
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !file.type.startsWith('image/')) {
                    // Use a custom modal instead of alert
                    const modal = document.createElement('div');
                    modal.innerHTML = `
                        <div class="edit-modal-overlay">
                            <div class="edit-modal">
                                <h3 class="text-lg font-bold text-center text-[var(--primary-glow)]">Ø®Ø·Ø£</h3>
                                <p class="text-white text-center">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù ØµÙˆØ±Ø©.</p>
                                <div class="flex justify-end gap-2">
                                    <button onclick="this.closest('.edit-modal-overlay').remove()" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">Ø¥ØºÙ„Ø§Ù‚</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    attachedImageBase64 = e.target.result;
                    addUserImageToChat(attachedImageBase64);
                    chatInput.placeholder = "Ø§ÙƒØªØ¨ Ø³Ø¤Ø§Ù„Ùƒ Ø£Ùˆ Ø£Ù…Ø±Ùƒ Ø¹Ù† Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©...";
                    chatInput.focus();
                };
                reader.readAsDataURL(file);
            });
            submitEditButton.addEventListener('click', handleEditSubmit);
            cancelEditButton.addEventListener('click', handleCancelEdit);

            // New event listeners for the dropdown menu
            optionsButton.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.toggle('hidden');
            });

            searchMenuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.add('hidden');
                handleSearch();
            });

            attachMenuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.add('hidden');
                handleAttachFiles();
            });

            window.addEventListener('click', () => {
                if (!dropdownMenu.classList.contains('hidden')) {
                    dropdownMenu.classList.add('hidden');
                }
            });


            // --- Text API Call with Exponential Backoff ---
            async function callTextAPI(payload) {
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];
                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                return candidate.content.parts[0].text;
                            } else {
                                throw new Error("Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Ø§Ù„ÙƒÙŠØ§Ù†.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `Ø®Ø·Ø£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                         if (attempts >= maxAttempts) {
                            throw error;
                         }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                 throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª.");
            }
            
            // --- Search API Call (Updated for robustness) ---
            async function callSearchAPI(query) {
                const payload = {
                    contents: [{
                        parts: [{ text: query }]
                    }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: searchSystemPrompt }]
                    },
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        // Check for ok status before parsing
                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];

                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                let sources = [];
                                const groundingMetadata = candidate.groundingMetadata;
                                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                                    // Make sure the sources are valid objects
                                    sources = groundingMetadata.groundingAttributions
                                        .map(attribution => ({
                                            uri: attribution.web?.uri,
                                            title: attribution.web?.title,
                                        }))
                                        .filter(source => source.uri && source.title);
                                }
                                return { text: candidate.content.parts[0].text, sources };
                            } else {
                                throw new Error("Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Ø§Ù„ÙƒÙŠØ§Ù†. Ù‚Ø¯ ØªÙƒÙˆÙ† ÙØ§Ø±ØºØ© Ø£Ùˆ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¨Ø³Ø¨Ø¨ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù….`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `Ø®Ø·Ø£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        console.error('ÙØ´Ù„ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ©:', error);
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª.");
            }
            
            // --- Prompt Translation API Call ---
            async function translatePrompt(text) {
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    systemInstruction: {
                        parts: [{ text: translationPrompt }]
                    },
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];
                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                return candidate.content.parts[0].text;
                            } else {
                                throw new Error("Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Ø§Ù„ÙƒÙŠØ§Ù†.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `Ø®Ø·Ø£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                         if (attempts >= maxAttempts) {
                            throw error;
                         }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                 throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª.");
            }


            // --- Image API Call with Exponential Backoff ---
            async function callImageAPI(prompt) {
                const payload = { 
                    instances: { prompt: prompt }, 
                    parameters: { "sampleCount": 1 } 
                };

                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(IMAGE_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                                return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                            } else {
                                throw new Error("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `Ø®Ø·Ø£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª.");
            }

            // --- TTS API Call ---
            async function callTTSAPI(text) {
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Kore" }
                            }
                        }
                    }
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TTS_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const part = result?.candidates?.[0]?.content?.parts?.[0];
                            const audioData = part?.inlineData?.data;
                            const mimeType = part?.inlineData?.mimeType;

                            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                                const pcmData = base64ToArrayBuffer(audioData);
                                const pcm16 = new Int16Array(pcmData);
                                const wavBlob = pcmToWav(pcm16, sampleRate);
                                return URL.createObjectURL(wavBlob);
                            } else {
                                throw new Error("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµÙˆØªÙŠØ© ÙÙŠ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ ${maxAttempts} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `Ø®Ø·Ø£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ÙØ´Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª.");
            }

            // --- Helper functions for audio conversion ---
            function base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bitsPerSample = 16;
                const byteRate = (bitsPerSample * sampleRate * numChannels) / 8;
                const blockAlign = (numChannels * bitsPerSample) / 8;
                const dataLength = pcmData.byteLength;
                
                const buffer = new ArrayBuffer(44 + dataLength);
                const view = new DataView(buffer);

                // RIFF identifier
                writeString(view, 0, 'RIFF');
                // file length
                view.setUint32(4, 36 + dataLength, true);
                // RIFF type
                writeString(view, 8, 'WAVE');
                // format chunk identifier
                writeString(view, 12, 'fmt ');
                // format chunk length
                view.setUint32(16, 16, true);
                // sample format (1 = PCM)
                view.setUint16(20, 1, true);
                // number of channels
                view.setUint16(22, numChannels, true);
                // sample rate
                view.setUint32(24, sampleRate, true);
                // byte rate
                view.setUint32(28, byteRate, true);
                // block align
                view.setUint16(32, blockAlign, true);
                // bits per sample
                view.setUint16(34, bitsPerSample, true);
                // data chunk identifier
                writeString(view, 36, 'data');
                // data chunk length
                view.setUint32(40, dataLength, true);
                
                // write the PCM data
                let offset = 44;
                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(offset, pcmData[i], true);
                    offset += 2;
                }
                
                return new Blob([view], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
        });
    </script>
</body>
</html>


