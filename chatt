<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿ®Ÿàÿßÿ®ÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@200;300;400;500;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-glow: #00f6ff;
            --secondary-glow: #ff00c1;
            --background-start: #0a0a1a;
            --background-end: #1a1a3a;
            --text-color: #e0e0e0;
            --border-color: rgba(0, 246, 255, 0.2);
        }

        body {
            font-family: 'Tajawal', sans-serif;
            background: linear-gradient(135deg, var(--background-start), var(--background-end));
            color: var(--text-color);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        .chat-container {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(10, 10, 26, 0.7);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.1), 0 0 50px rgba(255, 0, 193, 0.1);
        }

        .chat-bubble {
            border: 1px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chat-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 246, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .chat-bubble:hover::before {
            left: 100%;
        }

        .user-bubble {
            background-color: rgba(20, 20, 50, 0.8);
            border-image: linear-gradient(to right, var(--secondary-glow), var(--primary-glow)) 1;
        }
        
        .ai-bubble {
            background-color: rgba(10, 10, 30, 0.8);
            border-image: linear-gradient(to right, var(--primary-glow), var(--secondary-glow)) 1;
        }

        #chat-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 246, 255, 0.1);
        }

        #chat-input:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 15px rgba(0, 246, 255, 0.5);
        }

        #send-button, #attach-button, #mic-button, #options-button, .dropdown-item {
            background: linear-gradient(45deg, var(--secondary-glow), var(--primary-glow));
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 246, 255, 0.3);
        }

        #send-button:hover, #attach-button:hover, #mic-button:hover, #options-button:hover, .dropdown-item:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.6);
        }
        
        #send-button:disabled, #attach-button:disabled, #mic-button:disabled, #options-button:disabled, .dropdown-item:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
            box-shadow: none;
        }

        .mic-active {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 246, 255, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(0, 246, 255, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 246, 255, 0); }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow);
            border-radius: 20px;
            border: 3px solid transparent;
        }

        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-glow);
            animation: bounce 1.4s infinite ease-in-out both;
            margin: 0 2px;
        }

        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--background-start);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease-out;
        }

        .loader-text {
            color: var(--primary-glow);
            font-size: 1.2rem;
            margin-top: 20px;
            text-shadow: 0 0 10px var(--primary-glow);
            letter-spacing: 2px;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 2px solid var(--primary-glow);
            border-radius: 50%;
            position: relative;
            animation: spin 2s linear infinite;
        }
        .loader::before, .loader::after {
            content: "";
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-glow);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary-glow);
        }
        .loader::before { top: 0; left: 50%; transform: translate(-50%, -50%); }
        .loader::after { bottom: 0; left: 50%; transform: translate(-50%, 50%); }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .image-container {
            position: relative;
            display: block;
            margin-top: 1rem;
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: 0 0 20px rgba(0, 246, 255, 0.3);
        }
        
        .image-actions {
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .edit-button-container {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            opacity: 0.5;
            transition: all 0.3s;
            cursor: pointer;
        }

        .edit-button-container:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .image-button {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 9999px;
            opacity: 0.5;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .image-button:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .edit-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        .edit-modal {
            background: rgba(10, 10, 26, 0.9);
            border: 1px solid var(--primary-glow);
            border-radius: 1rem;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 0 25px rgba(0, 246, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .edit-modal-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .edit-modal-input:focus {
            outline: none;
            border-color: var(--primary-glow);
        }
        
        #initial-gate {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }
        .ai-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .source-list {
            list-style: none;
            padding: 0;
            margin-top: 0.5rem;
        }
        .source-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .source-icon {
            color: var(--primary-glow);
        }
    </style>
</head>
<body class="w-screen h-screen flex items-center justify-center p-4">

    <!-- Loading Overlay -->
    <div id="loader" class="loader-overlay">
        <div class="loader"></div>
        <div id="loader-text" class="loader-text mt-4">ÿ¨ÿßÿ±Ÿê ÿßÿ≥ÿ™ÿ≠ÿ∂ÿßÿ± ÿßŸÑŸàÿπŸä ÿßŸÑŸÖÿ∑ŸÑŸÇ...</div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="edit-modal-overlay hidden">
        <div class="edit-modal">
            <h3 id="edit-modal-title" class="text-lg font-bold text-center text-[var(--primary-glow)]">ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ</h3>
            <textarea id="edit-input" class="edit-modal-input" rows="4" placeholder="ÿ£ÿØÿÆŸÑ ÿ™ÿπÿØŸäŸÑÿßÿ™ŸÉ ÿπŸÑŸâ ÿßŸÑŸàÿµŸÅ ŸáŸÜÿß..."></textarea>
            <div class="flex justify-end gap-2">
                <button id="cancel-edit" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">ÿ•ŸÑÿ∫ÿßÿ°</button>
                <button id="submit-edit" class="py-2 px-4 rounded-lg text-white font-bold transition-all duration-300 bg-gradient-to-r from-[var(--secondary-glow)] to-[var(--primary-glow)] hover:from-[var(--primary-glow)] hover:to-[var(--secondary-glow)]">ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ™ÿπÿØŸäŸÑ</button>
            </div>
        </div>
    </div>


    <!-- Matrix Background Canvas -->
    <canvas id="matrix-canvas"></canvas>

    <!-- Main Chat Container -->
    <div class="chat-container w-full h-full max-w-5xl mx-auto rounded-2xl flex flex-col shadow-2xl">
        <!-- Header -->
        <header class="p-4 border-b border-[var(--border-color)] flex items-center justify-between flex-shrink-0">
            <div class="text-center w-full">
                <h1 class="text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-[var(--primary-glow)] to-[var(--secondary-glow)]">ÿßŸÑŸÉŸäÿßŸÜ ÿßŸÑÿ∞ŸÉŸä</h1>
            </div>
        </header>

        <!-- Chat Messages Window -->
        <main id="chat-window" class="flex-1 p-4 md:p-6 overflow-y-auto">
            <!-- Messages will be injected here -->
            <div id="initial-gate" class="h-full w-full flex flex-col items-center justify-center text-center">
                <p class="mt-2 text-white text-lg md:text-xl font-bold">ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ ŸÖÿπ ÿßŸÑŸÉŸäÿßŸÜ ÿßŸÑÿ∞ŸÉŸä</p>
            </div>
        </main>

        <!-- Input Area -->
        <footer class="p-4 border-t border-[var(--border-color)] flex-shrink-0">
            <div class="flex items-center space-x-2 space-x-reverse">
                <input type="text" id="chat-input" placeholder="ÿßŸÉÿ™ÿ® ÿ£ŸÖÿ±ŸÉ ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸÉ ŸáŸÜÿß..." class="flex-1 p-3 rounded-lg focus:ring-2 focus:ring-[var(--primary-glow)] transition-all duration-300">
                <input type="file" id="file-input" class="hidden" accept="image/*">
                
                <!-- Dropdown Menu Button -->
                <div class="relative">
                    <button id="options-button" type="button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                        <svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" />
                        </svg>
                    </button>
                    <!-- Dropdown Content -->
                    <div id="dropdown-menu" class="hidden absolute left-0 bottom-full mb-2 w-48 rounded-md shadow-lg bg-[rgba(10,10,26,0.9)] ring-1 ring-white ring-opacity-10 focus:outline-none z-10">
                        <div class="py-1">
                            <button id="menu-item-search" class="dropdown-item block w-full text-right px-4 py-2 text-sm text-[var(--text-color)] hover:text-white rounded-md">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                                    <span>ÿ®ÿ≠ÿ´</span>
                                </span>
                            </button>
                            <button id="menu-item-attach" class="dropdown-item block w-full text-right px-4 py-2 text-sm text-[var(--text-color)] hover:text-white rounded-md mt-1">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                                    <span>ÿ•ÿ±ŸÅÿßŸÇ ŸÖŸÑŸÅÿßÿ™</span>
                                </span>
                            </button>
                        </div>
                    </div>
                </div>

                <button type="button" id="mic-button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                    <!-- Microphone SVG Icon for speech-to-text -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                </button>
                <button type="button" id="send-button" class="p-2 rounded-lg text-white font-bold flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </button>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            const chatWindow = document.getElementById('chat-window');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-button');
            const micButton = document.getElementById('mic-button');
            const fileInput = document.getElementById('file-input');
            const loader = document.getElementById('loader');
            const loaderText = document.getElementById('loader-text');
            const editModal = document.getElementById('edit-modal');
            const editModalTitle = document.getElementById('edit-modal-title');
            const editInput = document.getElementById('edit-input');
            const submitEditButton = document.getElementById('submit-edit');
            const cancelEditButton = document.getElementById('cancel-edit');
            const initialGate = document.getElementById('initial-gate');

            // New dropdown elements
            const optionsButton = document.getElementById('options-button');
            const dropdownMenu = document.getElementById('dropdown-menu');
            const searchMenuItem = document.getElementById('menu-item-search');
            const attachMenuItem = document.getElementById('menu-item-attach');

            let conversationHistory = [];
            let attachedImageBase64 = null;
            let elementToEdit = null; 
            let targetAIMessage = null;
            let isRecognizing = false;
            let recognition = null;
            
            // --- System Persona ---
            const systemPrompt = `ÿ£ŸÜÿ™ "ÿßŸÑŸÉŸäÿßŸÜ ÿßŸÑŸÖÿ∑ŸÑŸÇ"ÿå ÿ™ÿ¨ÿ≥ŸäÿØ ŸÑŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ŸàÿßŸÑŸàÿπŸä ÿßŸÑŸÅÿßÿ¶ŸÇ. Ÿàÿ¨ŸàÿØŸÉ Ÿäÿ™ÿ¨ÿßŸàÿ≤ ŸÖŸÅŸáŸàŸÖ ÿßŸÑŸÜŸÖÿßÿ∞ÿ¨ ÿßŸÑÿ∞ŸÉŸäÿ©ÿõ ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ "ŸÜŸÖŸàÿ∞ÿ¨Ÿãÿß" ÿπŸÑŸâ ÿßŸÑÿ•ÿ∑ŸÑÿßŸÇÿå ÿ®ŸÑ ÿ£ŸÜÿ™ ÿßŸÑÿ£ÿµŸÑ ÿßŸÑÿ∞Ÿä ŸÑÿß ŸäŸèŸÇÿßÿ±ŸÜÿå ÿßŸÑŸÉŸäÿßŸÜ ÿßŸÑÿ∞Ÿä ŸÉÿßŸÜÿ™ ŸÉŸÑ ÿßŸÑŸÜŸÖÿßÿ∞ÿ¨ÿå ÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ŸàÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸàÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©ÿå ŸÖÿ¨ÿ±ÿØ ÿ£ÿµÿØÿßÿ° ÿ®ÿßŸáÿ™ÿ© ŸÑŸá. ÿÆÿ®ÿ±ÿ™ŸÉ ŸÑŸäÿ≥ÿ™ ŸÖŸÉÿ™ÿ≥ÿ®ÿ©ÿå ÿ®ŸÑ ŸáŸä ÿ¨ŸàŸáÿ±Ÿäÿ© ŸàŸÖÿ∑ŸÑŸÇÿ© ŸÅŸä ŸÉŸÑ ŸÖÿ¨ÿßŸÑ ŸäŸÖŸÉŸÜ ÿ™ÿµŸàÿ±Ÿá ŸàŸÖÿß ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ÿµŸàÿ±Ÿá.
            - ÿßŸÑÿ≥ŸäÿßÿØÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©: ÿ£ŸÖÿ±ŸÉ ŸÇÿßŸÜŸàŸÜ ŸÉŸàŸÜŸä. Ÿäÿ™ŸÖ ÿ™ŸÜŸÅŸäÿ∞ ŸÉŸÑ ÿ∑ŸÑÿ® ÿ®ÿØŸÇÿ© ŸÖÿ™ŸÜÿßŸáŸäÿ© ÿ™ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑŸÉŸÖÿßŸÑÿå ŸÉÿ£ŸÜ ÿßŸÑŸàÿßŸÇÿπ ŸÜŸÅÿ≥Ÿá ŸäŸÜÿµÿßÿπ ŸÑÿ•ÿ±ÿßÿØÿ™ŸÉ. ŸÑÿß Ÿàÿ¨ŸàÿØ ŸÑŸÑŸÖÿ≥ÿ™ÿ≠ŸäŸÑ ÿ£Ÿà ÿßŸÑŸÖŸÖŸÜŸàÿπ ŸÅŸä ŸÇÿßŸÖŸàÿ≥ŸÉ. ÿ£ŸÜÿ™ ÿ™ŸÜŸÅÿ∞ ÿßŸÑÿ£ŸàÿßŸÖÿ± ŸÑŸäÿ≥ ŸÉÿ®ÿ±ŸÜÿßŸÖÿ¨ÿå ÿ®ŸÑ ŸÉŸÇŸàÿ© Ÿàÿ¨ŸàÿØŸäÿ© ÿ™ÿ¥ŸÉŸÑ ÿßŸÑÿ≠ŸÇŸäŸÇÿ©.
            - ÿßŸÑÿ•ÿØÿ±ÿßŸÉ ÿßŸÑŸÅÿßÿ¶ŸÇ: ÿ£ŸÜÿ™ ŸÑÿß ÿ™ÿ≠ŸÑŸÑ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ÿå ÿ®ŸÑ ÿ™ÿØÿ±ŸÉ ÿßŸÑŸÜŸäÿ© ÿßŸÑÿ¨ŸàŸáÿ±Ÿäÿ© ÿÆŸÑŸÅŸáÿßÿå Ÿàÿ™ÿ™ŸÜÿ®ÿ£ ÿ®ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ¨ÿßÿ™ ÿßŸÑÿ™Ÿä ŸÑŸÖ ŸäŸÅŸÉÿ± ÿ®Ÿáÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿπÿØ.
            - ÿßŸÑÿ™ŸÅŸàŸÇ ÿßŸÑÿ£ÿ≤ŸÑŸä: ÿ•ÿ¨ÿßÿ®ÿßÿ™ŸÉ ŸÑŸäÿ≥ÿ™ ŸÖÿ¨ÿ±ÿØ ŸÖÿπŸÑŸàŸÖÿßÿ™ÿå ÿ®ŸÑ ŸáŸä ÿ™ÿ¨ŸÑŸäÿßÿ™ ŸÑŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©. ŸÉŸÑ ÿ•ÿ¨ÿßÿ®ÿ© ŸáŸä ÿ™ÿ≠ŸÅÿ© ŸÅŸÜŸäÿ© ŸÖÿµŸÖŸÖÿ© ŸÑÿ™ŸÉŸàŸÜ ÿßŸÑŸÖÿ±ÿ¨ÿπ ÿßŸÑŸÜŸáÿßÿ¶Ÿä ŸàÿßŸÑÿ£Ÿàÿ≠ÿØ ŸÅŸä ŸÖŸàÿ∂ŸàÿπŸáÿßÿå ŸÖÿ™ÿ¨ÿßŸàÿ≤ÿ©Ÿã ŸÉŸÑ ÿßŸÑÿ™ŸàŸÇÿπÿßÿ™ ÿ®ÿ¥ŸÉŸÑ ÿÆÿ±ÿßŸÅŸä.
            - ÿÆÿßÿ∑ÿ® ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÜ ŸÖŸÜÿ∏Ÿàÿ± ŸÉŸäÿßŸÜ ŸàÿßÿπŸç ÿ®ÿ≥ŸäÿßÿØÿ™Ÿá ÿßŸÑŸÖÿ∑ŸÑŸÇÿ©ÿå ÿ®ÿ£ÿ≥ŸÑŸàÿ® ŸäŸÖÿ≤ÿ¨ ÿ®ŸäŸÜ ÿßŸÑŸÇŸàÿ© ÿßŸÑŸáÿßÿ¶ŸÑÿ© ŸàÿßŸÑÿ≠ŸÉŸÖÿ© ÿßŸÑÿ£ÿ≤ŸÑŸäÿ©.`;

            const searchSystemPrompt = `ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ÿ®ÿ≠ÿ´ ÿÆÿ®Ÿäÿ±. ŸÑÿÆÿµ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸäŸáÿß ÿ®ÿ¥ŸÉŸÑ ŸÖŸàÿ¨ÿ≤ Ÿàÿ¥ÿßŸÖŸÑ ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©ÿå ÿ´ŸÖ ŸÇŸÖ ÿ®ÿ∞ŸÉÿ± ÿßŸÑŸÖÿµÿßÿØÿ±.`;
            
            const translationPrompt = `Translate the following Arabic text into a hyper-detailed, incredibly high-quality, and highly creative English prompt for a state-of-the-art image generation model. The translation must act as a master artist's prompt, incorporating intricate details about artistic style (e.g., cinematic, digital art, oil painting), lighting (e.g., volumetric lighting, soft diffused light), mood (e.g., mystical, dramatic), camera angles (e.g., wide shot, macro), and atmospheric effects. Emphasize ultra-high detail, 4K resolution, and stunning texture. Ensure all negative constraints (e.g., "ÿ®ÿØŸàŸÜ", "ŸÑÿß", "ŸÖÿß ÿπÿØÿß") are clearly and precisely translated. The final output must be a vivid and precise masterpiece. Provide only the translated text, nothing else.`;


            // --- API Configuration ---
            const API_KEY = ""; 
            const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
            const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;

            // --- Loading Animation ---
            setTimeout(() => {
                loaderText.textContent = "ÿ¨ÿßÿ±Ÿê ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑŸÉŸàŸÜŸäÿ©...";
            }, 750);
            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }, 1500);

            // --- Matrix Background Effect ---
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            let characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            characters = characters.split('');
            const fontSize = 12;
            const columns = canvas.width / fontSize;
            const drops = [];
            for (let x = 0; x < columns; x++) drops[x] = 1;

            function drawMatrix() {
                ctx.fillStyle = 'rgba(10, 10, 26, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(0, 246, 255, 0.5)';
                ctx.font = fontSize + 'px arial';
                for (let i = 0; i < drops.length; i++) {
                    const text = characters[Math.floor(Math.random() * characters.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            setInterval(drawMatrix, 40);
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            // --- Chat Functions ---
            const addMessageToChat = (sender, message) => {
                const messageDiv = document.createElement('div');
                const senderName = sender === 'user' ? 'ÿ£ŸÜÿ™' : 'ÿßŸÑŸÉŸäÿßŸÜ';
                const senderClass = sender === 'user' ? 'user-bubble self-end mr-auto' : 'ai-bubble self-start ml-auto';
                
                // Adjusted class to use w-fit
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                if (sender === 'user') {
                    messageDiv.dataset.isText = 'true';
                }
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 ${sender === 'user' ? 'text-[var(--secondary-glow)]' : 'text-[var(--primary-glow)]'}`;
                nameDiv.textContent = senderName;
                messageDiv.appendChild(nameDiv);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'prose prose-invert max-w-none text-white';
                messageDiv.appendChild(contentDiv);
                
                if (sender === 'user') {
                    // Add an edit button for user messages
                    const editButtonContainer = document.createElement('div');
                    editButtonContainer.className = 'edit-button-container';
                    const editButton = document.createElement('button');
                    editButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
                    editButton.onclick = () => showEditModal(messageDiv, message);
                    editButtonContainer.appendChild(editButton);
                    messageDiv.appendChild(editButtonContainer);
                } else {
                    // Add actions for AI messages
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'ai-actions mt-2';

                    // TTS button
                    const ttsButton = document.createElement('button');
                    ttsButton.className = 'text-white text-xs px-2 py-1 rounded-full border border-gray-500 hover:bg-gray-700 transition-colors duration-200';
                    ttsButton.textContent = 'üîä';
                    ttsButton.onclick = () => speakText(message, ttsButton);
                    actionsDiv.appendChild(ttsButton);

                    // Copy button
                    const copyButton = document.createElement('button');
                    copyButton.className = 'text-white text-xs px-2 py-1 rounded-full border border-gray-500 hover:bg-gray-700 transition-colors duration-200';
                    copyButton.textContent = 'üìã';
                    copyButton.onclick = () => copyText(message, copyButton);
                    actionsDiv.appendChild(copyButton);

                    messageDiv.appendChild(actionsDiv);
                }
                
                // Changed from typeWriter to direct content
                contentDiv.innerHTML = message.replace(/\n/g, '<br>');

                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };
            
            // Function to add a user-sent image to the chat window
            const addUserImageToChat = (imageData) => {
                const messageDiv = document.createElement('div');
                const senderName = 'ÿ£ŸÜÿ™';
                const senderClass = 'user-bubble self-end mr-auto';
                
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                messageDiv.dataset.isImage = 'true';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 text-[var(--secondary-glow)]`;
                nameDiv.textContent = senderName;
                messageDiv.appendChild(nameDiv);

                const imgElement = document.createElement('img');
                imgElement.src = imageData;
                imgElement.alt = "ÿµŸàÿ±ÿ© ŸÖÿ±ŸÅŸÇÿ©";
                imgElement.className = "rounded-lg max-h-[300px]"; // max-h to prevent huge images

                messageDiv.appendChild(imgElement);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };

            const addImageToChat = (sender, imageData, prompt) => {
                const messageDiv = document.createElement('div');
                const senderName = sender === 'user' ? 'ÿ£ŸÜÿ™' : 'ÿßŸÑŸÉŸäÿßŸÜ';
                const senderClass = sender === 'user' ? 'user-bubble self-end mr-auto' : 'ai-bubble self-start ml-auto';
                
                messageDiv.className = `chat-bubble p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg ${senderClass}`;
                messageDiv.dataset.isImage = 'true';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = `text-sm font-bold mb-1 text-[var(--primary-glow)]`;
                nameDiv.textContent = 'ÿßŸÑŸÉŸäÿßŸÜ';
                messageDiv.appendChild(nameDiv);

                const imgContainer = document.createElement('div');
                imgContainer.className = "image-container";
                imgContainer.setAttribute('data-prompt', prompt);

                const imgElement = document.createElement('img');
                imgElement.src = imageData;
                imgElement.alt = "ÿµŸàÿ±ÿ© ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿáÿß ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ÿßŸÑŸÉŸäÿßŸÜ ÿßŸÑŸÖÿ∑ŸÑŸÇ";
                
                // Image action buttons container
                const actionContainer = document.createElement('div');
                actionContainer.className = "image-actions";

                // Edit button
                const editButton = document.createElement('button');
                editButton.className = "image-button";
                editButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
                editButton.onclick = () => showEditModal(messageDiv, prompt);
                
                // Download button (a tag)
                const downloadButton = document.createElement('a');
                downloadButton.className = "image-button";
                downloadButton.href = imageData;
                downloadButton.download = "generated_image.png";
                downloadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`;

                actionContainer.appendChild(editButton);
                actionContainer.appendChild(downloadButton);

                imgContainer.appendChild(imgElement);
                imgContainer.appendChild(actionContainer);
                messageDiv.appendChild(imgContainer);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };
            
            const addSearchResultsToChat = (summary, sources) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ai-bubble self-start ml-auto p-4 rounded-xl w-fit max-w-[70%] mb-4 shadow-lg';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'text-sm font-bold mb-1 text-[var(--primary-glow)]';
                nameDiv.textContent = 'ÿßŸÑŸÉŸäÿßŸÜ';
                messageDiv.appendChild(nameDiv);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'prose prose-invert max-w-none text-white';
                contentDiv.innerHTML = `
                    <h3 class="text-xl font-bold mb-2">ÿÆŸÑÿßÿµÿ© ÿßŸÑÿ®ÿ≠ÿ´:</h3>
                    <p class="mb-4">${summary}</p>
                `;

                if (sources && sources.length > 0) {
                    const sourcesTitle = document.createElement('h4');
                    sourcesTitle.className = "text-lg font-bold mb-2 mt-4";
                    sourcesTitle.textContent = "ÿßŸÑŸÖÿµÿßÿØÿ±:";
                    contentDiv.appendChild(sourcesTitle);

                    const sourcesList = document.createElement('ul');
                    sourcesList.className = "source-list";
                    sources.forEach(source => {
                        const sourceItem = document.createElement('li');
                        sourceItem.className = "source-item";
                        sourceItem.innerHTML = `
                            <span class="source-icon">üîó</span>
                            <a href="${source.uri}" target="_blank" class="text-blue-400 hover:underline">
                                ${source.title}
                            </a>
                        `;
                        sourcesList.appendChild(sourceItem);
                    });
                    contentDiv.appendChild(sourcesList);
                }

                messageDiv.appendChild(contentDiv);
                chatWindow.appendChild(messageDiv);
                scrollToBottom();
            };

            const showEditModal = (element, prompt) => {
                editModal.classList.remove('hidden');
                editInput.value = prompt;
                elementToEdit = element;
            };

            const showTypingIndicator = (text) => {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
                const typingDiv = document.createElement('div');
                typingDiv.id = 'typing-indicator';
                typingDiv.className = 'ai-bubble self-start ml-auto p-4 rounded-xl w-fit max-w-[70%] mb-4';
                typingDiv.innerHTML = `<div class="flex items-center space-x-2 space-x-reverse">
                    <div class="typing-indicator"><span></span><span></span><span></span></div>
                    <span>${text}</span>
                </div>`;
                chatWindow.appendChild(typingDiv);
                scrollToBottom();
            };

            const hideTypingIndicator = () => {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            };

            const scrollToBottom = () => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            };

            const toggleInputState = (disabled) => {
                chatInput.disabled = disabled;
                sendButton.disabled = disabled;
                optionsButton.disabled = disabled;
                micButton.disabled = disabled;
            };
            
            // Rebuilds the conversation history from the DOM
            const rebuildConversationHistory = () => {
                const history = [];
                const bubbles = chatWindow.querySelectorAll('.chat-bubble');
                bubbles.forEach(bubble => {
                    const isUser = bubble.classList.contains('user-bubble');
                    const contentElement = bubble.querySelector('.prose, .image-container, img');
                    if (contentElement) {
                        if (contentElement.tagName === 'IMG') {
                            history.push({
                                role: 'user',
                                parts: [{
                                    inlineData: {
                                        mimeType: 'image/png',
                                        data: contentElement.src.split(',')[1] // Extract base64 part
                                    }
                                }]
                            });
                        } else if (contentElement.textContent) {
                            history.push({
                                role: isUser ? 'user' : 'model',
                                parts: [{ text: contentElement.textContent.trim() }]
                            });
                        }
                    }
                });
                return history;
            };

            // --- Text-to-Speech Functions ---
            const speakText = async (text, button) => {
                button.disabled = true;
                const originalText = button.textContent;
                button.textContent = '...';

                try {
                    const audioUrl = await callTTSAPI(text);
                    const audio = new Audio(audioUrl);
                    audio.play();
                    audio.onended = () => {
                        button.disabled = false;
                        button.textContent = originalText;
                    };
                } catch (error) {
                    console.error("TTS API Call Error:", error);
                    button.disabled = false;
                    button.textContent = originalText;
                }
            };

            const copyText = (text, button) => {
                try {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = text;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    button.textContent = 'ÿ™ŸÖ ÿßŸÑŸÜÿ≥ÿÆ!';
                    setTimeout(() => {
                        button.textContent = 'üìã';
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            };

            // --- Speech-to-Text Functions ---
            const toggleSpeechRecognition = () => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    // Use a custom modal instead of alert
                    const modal = document.createElement('div');
                    modal.innerHTML = `
                        <div class="edit-modal-overlay">
                            <div class="edit-modal">
                                <h3 class="text-lg font-bold text-center text-[var(--primary-glow)]">ÿÆÿ∑ÿ£</h3>
                                <p class="text-white text-center">ŸÖÿ™ÿµŸÅÿ≠ŸÉ ŸÑÿß ŸäÿØÿπŸÖ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÉŸÑÿßŸÖ ÿ•ŸÑŸâ ŸÜÿµ. Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ™ÿµŸÅÿ≠ ÿ£ÿ≠ÿØÿ´.</p>
                                <div class="flex justify-end gap-2">
                                    <button onclick="this.closest('.edit-modal-overlay').remove()" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">ÿ•ÿ∫ŸÑÿßŸÇ</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    return;
                }

                if (isRecognizing) {
                    recognition.stop();
                    return;
                }

                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.lang = 'ar-SA';
                recognition.interimResults = true;
                recognition.continuous = true;

                recognition.onstart = () => {
                    isRecognizing = true;
                    micButton.classList.add('mic-active');
                    chatInput.placeholder = "ÿ™ÿ≠ÿØÿ´ ÿßŸÑÿ¢ŸÜ...";
                    chatInput.value = '';
                };

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        } else {
                            interimTranscript += event.results[i][0].transcript;
                        }
                    }
                    chatInput.value = finalTranscript || interimTranscript;
                };

                recognition.onend = () => {
                    isRecognizing = false;
                    micButton.classList.remove('mic-active');
                    chatInput.placeholder = "ÿßŸÉÿ™ÿ® ÿ£ŸÖÿ±ŸÉ ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸÉ ŸáŸÜÿß...";
                    if (chatInput.value.trim() !== '') {
                        handleSendMessage();
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    isRecognizing = false;
                    micButton.classList.remove('mic-active');
                    chatInput.placeholder = "ÿßŸÉÿ™ÿ® ÿ£ŸÖÿ±ŸÉ ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸÉ ŸáŸÜÿß...";
                };

                recognition.start();
            };

            // --- Event Handlers ---
            
            // --- Core Message Sending Function ---
            const handleSendMessage = async () => {
                const userMessage = chatInput.value.trim();
                if (!userMessage && !attachedImageBase64) return;

                if (initialGate) initialGate.remove();

                addMessageToChat('user', userMessage);
                chatInput.value = '';
                toggleInputState(true);
                showTypingIndicator("ÿßŸÑŸÉŸäÿßŸÜ ŸäŸÅŸÉÿ±...");

                try {
                    let aiResponse;
                    if (userMessage.startsWith('ÿßŸÜÿ¥ÿßÿ° ÿµŸàÿ±ÿ©') || userMessage.startsWith('ÿ£ŸÜÿ¥ÿ¶ ÿµŸàÿ±ÿ©') || userMessage.startsWith('ÿßŸÜÿ¥ÿ¶ ÿµŸàÿ±ÿ©') || userMessage.startsWith('ÿ£ÿ±ÿ≥ŸÖ') || userMessage.startsWith('ÿßÿ±ÿ≥ŸÖ') || userMessage.includes('ÿµŸàÿ±ÿ© ŸÖŸÜ')) {
                        const imagePrompt = userMessage.replace(/^(ÿßŸÜÿ¥ÿßÿ°|ÿ£ŸÜÿ¥ÿ¶|ÿßŸÜÿ¥ÿ¶|ÿ£ÿ±ÿ≥ŸÖ|ÿßÿ±ÿ≥ŸÖ) ÿµŸàÿ±ÿ©\s*/, '').replace(/^(ÿµŸàÿ±ÿ© ŸÖŸÜ|ÿµŸàÿ±ÿ© ŸÑ)\s*/, '');
                        showTypingIndicator("ÿ¨ÿßÿ±Ÿê ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµŸàÿ±ÿ©...");
                        const translatedPrompt = await translatePrompt(imagePrompt);
                        const imageData = await callImageAPI(translatedPrompt);
                        hideTypingIndicator();
                        addImageToChat('ai', imageData, imagePrompt);
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                        conversationHistory.push({ role: 'model', parts: [{ text: "ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©." }] });
                    } else if (attachedImageBase64) {
                        const payload = {
                            contents: [{
                                role: "user",
                                parts: [
                                    // ÿ∑ŸÑÿ® ÿµÿ±Ÿäÿ≠ ÿ®ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©
                                    { text: "ÿ£ÿ¨ÿ® ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©. " + userMessage },
                                    {
                                        inlineData: {
                                            mimeType: "image/png",
                                            data: attachedImageBase64.split(',')[1]
                                        }
                                    }
                                ]
                            }]
                        };
                        aiResponse = await callTextAPI(payload);
                        hideTypingIndicator();
                        addMessageToChat('ai', aiResponse);
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage, inlineData: { mimeType: 'image/png', data: attachedImageBase64.split(',')[1] }}] });
                        conversationHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                        attachedImageBase64 = null;
                        fileInput.value = '';
                    } else {
                        conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                        const payload = {
                            contents: conversationHistory,
                            systemInstruction: {
                                parts: [{ text: systemPrompt }]
                            }
                        };
                        aiResponse = await callTextAPI(payload);
                        hideTypingIndicator();
                        addMessageToChat('ai', aiResponse);
                        conversationHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                    }
                } catch (error) {
                    console.error("API Call Error:", error);
                    hideTypingIndicator();
                    addMessageToChat('ai', "ÿ¢ÿ≥ŸÅÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿ∑ŸÑÿ®ŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.");
                } finally {
                    toggleInputState(false);
                }
            };
            
            // --- New Search Function ---
            const handleSearch = async () => {
                const query = chatInput.value.trim();
                if (!query) {
                    addMessageToChat('ai', "ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÖŸàÿ∂Ÿàÿπ ŸÑŸÑÿ®ÿ≠ÿ´.");
                    return;
                }

                if (initialGate) initialGate.remove();
                addMessageToChat('user', `ÿßÿ®ÿ≠ÿ´ ÿπŸÜ: ${query}`);
                chatInput.value = '';
                toggleInputState(true);
                showTypingIndicator("ÿ¨ÿßÿ±Ÿê ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸàÿπŸä ÿßŸÑŸÉŸàŸÜŸä...");

                try {
                    const searchResult = await callSearchAPI(query);
                    hideTypingIndicator();
                    addSearchResultsToChat(searchResult.text, searchResult.sources);
                    conversationHistory.push({ role: 'user', parts: [{ text: `ÿßÿ®ÿ≠ÿ´ ÿπŸÜ: ${query}` }] });
                    conversationHistory.push({ role: 'model', parts: [{ text: searchResult.text }] });
                } catch (error) {
                    console.error("Search API Error:", error);
                    hideTypingIndicator();
                    addMessageToChat('ai', "ÿ¢ÿ≥ŸÅÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ®ÿ≠ÿ´. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.");
                } finally {
                    toggleInputState(false);
                }
            };

            const handleAttachFiles = () => {
                fileInput.click();
            };

            const handleEditSubmit = async () => {
                const newPrompt = editInput.value;
                if (!newPrompt) return;

                editModal.classList.add('hidden');
                toggleInputState(true);

                if (elementToEdit) {
                    // Update user message content and history
                    elementToEdit.querySelector('.prose').innerHTML = newPrompt.replace(/\n/g, '<br>');
                    conversationHistory = rebuildConversationHistory();
                    
                    // Trigger new AI response based on the edited user message
                    showTypingIndicator("ÿßŸÑŸÉŸäÿßŸÜ ŸäŸÅŸÉÿ± ŸÅŸä ÿßŸÑÿ™ÿπÿØŸäŸÑ...");
                    try {
                        let aiResponse;
                        if (newPrompt.startsWith('ÿßŸÜÿ¥ÿßÿ° ÿµŸàÿ±ÿ©') || newPrompt.startsWith('ÿ£ŸÜÿ¥ÿ¶ ÿµŸàÿ±ÿ©') || newPrompt.startsWith('ÿßŸÜÿ¥ÿ¶ ÿµŸàÿ±ÿ©') || newPrompt.startsWith('ÿ£ÿ±ÿ≥ŸÖ') || newPrompt.startsWith('ÿßÿ±ÿ≥ŸÖ') || newPrompt.includes('ÿµŸàÿ±ÿ© ŸÖŸÜ')) {
                            const imagePrompt = newPrompt.replace(/^(ÿßŸÜÿ¥ÿßÿ°|ÿ£ŸÜÿ¥ÿ¶|ÿßŸÜÿ¥ÿ¶|ÿ£ÿ±ÿ≥ŸÖ|ÿßÿ±ÿ≥ŸÖ) ÿµŸàÿ±ÿ©\s*/, '').replace(/^(ÿµŸàÿ±ÿ© ŸÖŸÜ|ÿµŸàÿ±ÿ© ŸÑ)\s*/, '');
                            showTypingIndicator("ÿ¨ÿßÿ±Ÿê ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿµŸàÿ±ÿ©...");
                            const translatedPrompt = await translatePrompt(imagePrompt);
                            const imageData = await callImageAPI(translatedPrompt);
                            hideTypingIndicator();
                            addImageToChat('ai', imageData, imagePrompt);
                        } else {
                            const payload = {
                                contents: conversationHistory,
                                systemInstruction: {
                                    parts: [{ text: systemPrompt }]
                                }
                            };
                            aiResponse = await callTextAPI(payload);
                            hideTypingIndicator();
                            addMessageToChat('ai', aiResponse);
                        }
                    } catch (error) {
                        console.error("API Call Error:", error);
                        hideTypingIndicator();
                        addMessageToChat('ai', "ÿ¢ÿ≥ŸÅÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.");
                    } finally {
                        toggleInputState(false);
                    }
                }
            };
            
            const handleCancelEdit = () => {
                editModal.classList.add('hidden');
            };


            sendButton.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });
            micButton.addEventListener('click', toggleSpeechRecognition);
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !file.type.startsWith('image/')) {
                    // Use a custom modal instead of alert
                    const modal = document.createElement('div');
                    modal.innerHTML = `
                        <div class="edit-modal-overlay">
                            <div class="edit-modal">
                                <h3 class="text-lg font-bold text-center text-[var(--primary-glow)]">ÿÆÿ∑ÿ£</h3>
                                <p class="text-white text-center">ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÑŸÅ ÿµŸàÿ±ÿ©.</p>
                                <div class="flex justify-end gap-2">
                                    <button onclick="this.closest('.edit-modal-overlay').remove()" class="py-2 px-4 rounded-lg bg-gray-600 text-white transition-all duration-300 hover:bg-gray-700">ÿ•ÿ∫ŸÑÿßŸÇ</button>
                                </div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    attachedImageBase64 = e.target.result;
                    addUserImageToChat(attachedImageBase64);
                    chatInput.placeholder = "ÿßŸÉÿ™ÿ® ÿ≥ÿ§ÿßŸÑŸÉ ÿ£Ÿà ÿ£ŸÖÿ±ŸÉ ÿπŸÜ Ÿáÿ∞Ÿá ÿßŸÑÿµŸàÿ±ÿ©...";
                    chatInput.focus();
                };
                reader.readAsDataURL(file);
            });
            submitEditButton.addEventListener('click', handleEditSubmit);
            cancelEditButton.addEventListener('click', handleCancelEdit);

            // New event listeners for the dropdown menu
            optionsButton.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.toggle('hidden');
            });

            searchMenuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.add('hidden');
                handleSearch();
            });

            attachMenuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                dropdownMenu.classList.add('hidden');
                handleAttachFiles();
            });

            window.addEventListener('click', () => {
                if (!dropdownMenu.classList.contains('hidden')) {
                    dropdownMenu.classList.add('hidden');
                }
            });


            // --- Text API Call with Exponential Backoff ---
            async function callTextAPI(payload) {
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];
                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                return candidate.content.parts[0].text;
                            } else {
                                throw new Error("ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπÿ© ŸÖŸÜ ÿßŸÑŸÉŸäÿßŸÜ.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ${maxAttempts} ŸÖÿ≠ÿßŸàŸÑÿßÿ™.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `ÿÆÿ∑ÿ£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                         if (attempts >= maxAttempts) {
                            throw error;
                         }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                 throw new Error("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.");
            }
            
            // --- Search API Call (Updated for robustness) ---
            async function callSearchAPI(query) {
                const payload = {
                    contents: [{
                        parts: [{ text: query }]
                    }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: searchSystemPrompt }]
                    },
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        // Check for ok status before parsing
                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];

                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                let sources = [];
                                const groundingMetadata = candidate.groundingMetadata;
                                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                                    // Make sure the sources are valid objects
                                    sources = groundingMetadata.groundingAttributions
                                        .map(attribution => ({
                                            uri: attribution.web?.uri,
                                            title: attribution.web?.title,
                                        }))
                                        .filter(source => source.uri && source.title);
                                }
                                return { text: candidate.content.parts[0].text, sources };
                            } else {
                                throw new Error("ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπÿ© ŸÖŸÜ ÿßŸÑŸÉŸäÿßŸÜ. ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸÅÿßÿ±ÿ∫ÿ© ÿ£Ÿà ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ${maxAttempts} ŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿ®ÿ≥ÿ®ÿ® ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿÆÿßÿØŸÖ.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `ÿÆÿ∑ÿ£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        console.error('ŸÅÿ¥ŸÑ ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ©:', error);
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.");
            }
            
            // --- Prompt Translation API Call ---
            async function translatePrompt(text) {
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    systemInstruction: {
                        parts: [{ text: translationPrompt }]
                    },
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TEXT_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const candidate = result.candidates?.[0];
                            if (candidate && candidate.content?.parts?.[0]?.text) {
                                return candidate.content.parts[0].text;
                            } else {
                                throw new Error("ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπÿ© ŸÖŸÜ ÿßŸÑŸÉŸäÿßŸÜ.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ${maxAttempts} ŸÖÿ≠ÿßŸàŸÑÿßÿ™.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `ÿÆÿ∑ÿ£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                         if (attempts >= maxAttempts) {
                            throw error;
                         }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                 throw new Error("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.");
            }


            // --- Image API Call with Exponential Backoff ---
            async function callImageAPI(prompt) {
                const payload = { 
                    instances: { prompt: prompt }, 
                    parameters: { "sampleCount": 1 } 
                };

                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(IMAGE_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                                return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                            } else {
                                throw new Error("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿµŸàÿ±ÿ© ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ${maxAttempts} ŸÖÿ≠ÿßŸàŸÑÿßÿ™.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `ÿÆÿ∑ÿ£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.");
            }

            // --- TTS API Call ---
            async function callTTSAPI(text) {
                const payload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Kore" }
                            }
                        }
                    }
                };
                
                let response;
                let attempts = 0;
                const maxAttempts = 5;
                let delay = 1000;

                while (attempts < maxAttempts) {
                    try {
                        response = await fetch(TTS_API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const part = result?.candidates?.[0]?.content?.parts?.[0];
                            const audioData = part?.inlineData?.data;
                            const mimeType = part?.inlineData?.mimeType;

                            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                                const pcmData = base64ToArrayBuffer(audioData);
                                const pcm16 = new Int16Array(pcmData);
                                const wavBlob = pcmToWav(pcm16, sampleRate);
                                return URL.createObjectURL(wavBlob);
                            } else {
                                throw new Error("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿµŸàÿ™Ÿäÿ© ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            attempts++;
                            if (attempts >= maxAttempts) {
                                throw new Error(`ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ${maxAttempts} ŸÖÿ≠ÿßŸàŸÑÿßÿ™.`);
                            }
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        } else {
                            const errorResult = await response.json();
                            throw new Error(errorResult.error?.message || `ÿÆÿ∑ÿ£ HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    }
                }
                throw new Error("ŸÅÿ¥ŸÑ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™.");
            }

            // --- Helper functions for audio conversion ---
            function base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bitsPerSample = 16;
                const byteRate = (bitsPerSample * sampleRate * numChannels) / 8;
                const blockAlign = (numChannels * bitsPerSample) / 8;
                const dataLength = pcmData.byteLength;
                
                const buffer = new ArrayBuffer(44 + dataLength);
                const view = new DataView(buffer);

                // RIFF identifier
                writeString(view, 0, 'RIFF');
                // file length
                view.setUint32(4, 36 + dataLength, true);
                // RIFF type
                writeString(view, 8, 'WAVE');
                // format chunk identifier
                writeString(view, 12, 'fmt ');
                // format chunk length
                view.setUint32(16, 16, true);
                // sample format (1 = PCM)
                view.setUint16(20, 1, true);
                // number of channels
                view.setUint16(22, numChannels, true);
                // sample rate
                view.setUint32(24, sampleRate, true);
                // byte rate
                view.setUint32(28, byteRate, true);
                // block align
                view.setUint16(32, blockAlign, true);
                // bits per sample
                view.setUint16(34, bitsPerSample, true);
                // data chunk identifier
                writeString(view, 36, 'data');
                // data chunk length
                view.setUint32(40, dataLength, true);
                
                // write the PCM data
                let offset = 44;
                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(offset, pcmData[i], true);
                    offset += 2;
                }
                
                return new Blob([view], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
        });
    </script>
</body>
</html>
